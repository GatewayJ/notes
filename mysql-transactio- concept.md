---
author : "jihongwei"
tags : ["mysql"]
date : 2020-11-16T11:24:00Z
title : "mysql事务相关的概念"
---

### 1.事务的特性： 

- 原子性
- 一致性
- 隔离性
- 持久性

### 2.不同的事务隔离级别：

- 读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。
- 读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。
- 可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。读取的数据为当前事务版本，更新数据是在最新提交的版本上更新，（如果要更新的行，在其他未提交的事务中也执行了更新操作，则等待事务提交或超时报错（写的时候加了写锁，未提交时不允许其他事务写））（在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在当前读下才会出现。）
- 串行：我的事务尚未提交，别人就别想改数据。

这4种隔离级别，从上到下并行性能依次降低，安全性依次提高。

### 3.
* 脏读：

    如果一个事务对数据进行了更新，但事务还没有提交，另一个事务就可以“看到”该事务没有提交的更新结果。这样就造成的问题就是，如果第一个事务回滚，那么第二个事务在此之前所“看到”的数据就是一笔脏数据
    此情况仅会发生在： 读未提交的的隔离级别.
* 不可重复读：

1.B事务读取了两次数据，在这两次的读取过程中A事务修改了数据，B事务的这两次读取出来的数据不一样。

2.不可重复读有一种特殊情况，两个事务更新同一条数据资源，后完成的事务会造成先完成的事务更新丢失。这种情况就是大名鼎鼎的第二类丢失更新

第一条是B事务读取了A事务的更改，第二条是B事务更改了A事务的更改.

此情况仅会发生在：读未提交、读提交的隔离级别.
  
###  4、幻读

一个事务按相同的查询条件重新读取以前检索过的数据,却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。

幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。此情况会回发生在：读未提交、读提交隔离级别.

### 5.

第一类更新丢失：现代数据库中不会发生这种情况，是指，由于某个事务的回滚操作，参与回滚的旧数据将其他事务的数据更新覆盖了。比如如下两个事务，事务一先开启查询账户有1000元，然后准备存款100元，使其账户变为1100，此时事务尚未结束，其后，事务二发生了转账，并提交了事务，使账户金额变为900，而事务一并不知情，最后事务一没有提交，而是回滚了事务，将账户金额重新设置为1000。但其实，账户已经被转走了100元，这种回滚导致了更新丢失。幻读的回滚也会造成第一类更新丢失。


第二类丢失更新:两个事务更新同一条数据资源，后完成的事务会造成先完成的事务更新丢失。


解决的方式为（不可重复复读级别不会产生此类问题）

- 悲观锁

#悲观锁就是锁定要更新的这一行，然后在事务提交之前不让其他事务对该行数据做任何操作,直至释放行锁
```
select money from account where id=10 for update
money = money + 100
update account set money =  money where id =10
```

- 乐观锁

#乐观锁是在并发的表上加一个version字段，更新的时候只有版本号大于当前版本号才能更新成功
```
select money，version from account where id=10 for update
money = money + 100
version = version + 1
update account set money =  money where id =10 and version > version
```

另外要注意：MVCC在RR和RC隔离级别下的区别，在RR隔离级别下，一个事务只能读取到事务开始的那个时刻的数据快照，即，别的事务修改并提交的数据在自身没有提交之前一般读取不到（加for update语句的select除外，因为这个语句要对数据加X锁必须读取最新的数据快照），在RC隔离级别下，事务总是读取数据行的最新快照，即会产生不可重复读的问题。

悲观锁适合读少写多的情况,乐观锁适合读多写少的情况


在MySQL中，事务隔离级别RC(read commit)和RR（repeatable read）两种事务隔离级别基于多版本并发控制MVCC(multi-version concurrency control）来实现。
 


-----


当前读和快照度


1.当前读:

```
　　select...lock in share mode (共享读锁)
　　select...for update
　　update , delete , insert
```

　　当前读, 读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。


　　例如，假设要update一条记录，但是另一个事务已经delete这条数据并且commit了，如果不加锁就会产生冲突。所以update的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。

当前读的实现方式：next-key锁(行记录锁+Gap间隙锁)


间隙锁：只有在Read Repeatable、Serializable隔离级别才有，就是锁定范围空间的数据，假设id有3,4,5，锁定id>3的数据，是指的4，5及后面的数字都会被锁定，因为此时如果不锁定没有的数据，例如当加入了新的数据id=6，就会出现幻读，间隙锁避免了幻读。

1.对主键或唯一索引，如果当前读时，where条件全部精确命中(=或者in)，这种场景本身就不会出现幻读，所以只会加行记录锁。

2.没有索引的列，当前读操作时，会加全表gap锁，生产环境要注意。

3.非唯一索引列，如果where条件部分命中(>、<、like等)或者全未命中，则会加附近Gap间隙锁。例如，某表数据如下，非唯一索引2,6,9,9,11,15。如下语句要操作非唯一索引列9的数据，gap锁将会锁定的列是(6,11]，该区间内无法插入数据。


 2.快照读

 单纯的select操作，不包括上述 select ... lock in share mode, select ... for update。

Read Committed隔离级别：每次select都生成一个快照读。

Read Repeatable隔离级别：开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。

快照读的实现方式：undolog和多版本并发控制MVCC


由于RC隔离级别需要保持语句级别的一致行，事务中每一次读取都是访问当前时间点的已提交数据，因此事务中多条查询语句会创建多个不同的ReadView，开销较大，复杂度更高，而对于RR隔离级别，仅需要一个版本的ReadView，消耗更少，因此Mysql默认使用RR隔离级别。

RC隔离级别获得的是语句级读一致性

RR隔离级别获得的是事务级读一致性

当前读总是读取最新版本的数据。

