---
author : "jihongwei"
tags : ["linux"]
date : 2018-02-20T11:24:00Z
title : "进程，线程"
---

http://blog.csdn.net/gatieme/article/details/51892437
http://blog.csdn.net/u012927281/article/details/51602898



***进程和线程都被叫做上下文***


在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。（所谓独立调度的基本单位就是被内核调度的基本单位）


根据操作系统内核是否对线程可感知，可以把线程分为内核线程和用户线程


（在内核线程的支持下，LWP是独立的调度单元，就像普通的进程一样。所以LWP的最大特点还是每个LWP都有一个内核线程支持 
轻量级进程 (LWP, light weight process) 是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有 LWP 。每一个进程有一个或多个 LWPs ，每个 LWP 由一个内核线程支持。）


内核线程没有用户内存空间，与之相对的是用户进程（注意，此处不是用户线程，用户线程内存空间与用户进程空间之间存在的一定差异，具体差异可以参考我之前的博文），用户进程同时具备内核空间与用户空间，在进行系统调用时用户进程会由用户内存空间陷入内核内存空间。之所以此处采用内核线程与用户进程（而非用户线程）进行对比，是由于内核线程（kernel thread）是“独立运行在内核空间的标准进程”（以上这句话摘自《linux内核设计与实现》），因此从功能上看内核线程一方面具有进程的概念特点——具有独立功能的程序关于某个数据集合上的一次执行活动，是系统进行资源分配的单位，同时内核线程又具有线程的概念特点——进程内的一个可调度实体。


从实现的角度来看linux内核本身并不支持线程这一概念，linux 将所有的线程都当作进程来实现。内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程。相反，线程仅仅被视为一个与其他进程（概念上应该是线程）共享某些资源的进程（概念上应该是线程）。每个线程都拥有唯一隶属于自己的task_struct，所以在内核中，它看起来就像是一个普通的进程（只是线程和其他一些进程共享某些资源，如地址空间）。在linux2.6之前，内核并不支持线程的概念，仅通过轻量级进程（lightweight process）模拟线程，一个用户线程对应一个内核线程（内核轻量级进程），这种模型最大的特点是线程调度由内核完成了，而其他线程操作（同步、取消）等都是核外的线程库（LinuxThread）函数完成的。在linux2.6之后，为了完全兼容posix标准，linux2.6首先对内核进行了改进，引入了线程组的概念（仍然用轻量级进程表示线程），有了这个概念就可以将一组线程组织称为一个进程，如此通过这个改变，linux内核正式支持多线程特性。


1.线程的用户级线程实现方式
库调度器从进程的多个线程中选择一个线程，然后该线程和该进程允许的一个内核线程关联起来。内核线程将被操作系统调度器指派到处理器内核。用户级线程是一种”多对一”的线程映射。
在用户级线程中，有关线程的管理工作都有应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序（为了在操作系统中加入线程支持，采用了在用户空间增加运行库来实现线程，这些运行库被称为“线程包”，用户线程是不能被操作系统所感知的）。


用户进程利用线程库来控制用户线程。由于线程在进程内切换的规则远比进程调度和切换的规则简单，不需要用户态/核心态切换，所以切换速度快。但是由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。


内核为每个线程都映射调度实体，如果系统出现大量线程，会对系统性能有影响。但该模型的实用性还是高于多对一的线程模型。

LinuxThread与NPTL都是采用这种模型。

![用户空间线程](https://demoio.cn:90/blog-image/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%BA%BF%E7%A8%8B.png)



用户线程的优点主要有：

1.可以在不支持线程的操作系统中实现。

2.创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多, 因为保存线程状态的过程和调用程序都只是本地过程    
允许每个进程定制自己的调度算法，线程管理比较灵活。这就是必须自己写管理程序，与内核线程的区别

3.线程能够利用的表空间和堆栈空间比内核级线程多
不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，使得线程调用非常快捷

4.线程的调度不需要内核直接参与，控制简单。

用户线程的缺点主要有：

1.当然线程的一些其他操作还是要经过内核，如IO读写。这样导致了一个问题：当多线程并发执行时，如果其中一个线程执行IO操作时，内核接管这个操作，如果IO阻塞，用户态的其他线程都会被阻塞，因为这些线程都对应同一个内核调度实体。在多处理器机器上，内核不知道用户态有这些线程，无法把它们调度到其他处理器，也无法通过优先级来调度。这对线程的使用是没有意义的！

2.页面失效也会产生类似的问题。
3.一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程

4.资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用

***2.在内核级线程中***


内核线程建立和销毁都是由操作系统负责、通过系统调用完成的。在内核的支持下运行，无论是用户进程的线程，或者是系统进程的线程，他们的创建、撤销、切换都是依靠内核实现的。

在linux中通过LWP（lightweight process）作为线程概念的支持，轻量级线程(LWP)是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有LWP。

由于每个LWP都与一个特定的内核线程关联，因此每个LWP都是一个独立的线程调度单元。即使有一个LWP在系统调用中阻塞，也不会影响整个进程的执行。

轻量级进程具有局限性。首先，大多数LWP的操作，如建立、析构以及同步，都需要进行系统调用。系统调用的代价相对较高：需要在user mode和kernel mode中切换。其次，每个LWP都需要有一个内核线程支持，因此LWP要消耗内核资源（内核线程的栈空间）。因此一个系统不能支持大量的LWP

线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口. 内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成.

内核线程驻留在内核空间，它们是内核对象。有了内核线程，每个用户线程被映射或绑定到一个内核线程。用户线程在其生命期内都会绑定到该内核线程。一旦用户线程终止，两个线程都将离开系统。这被称作”一对一”线程映射，

![一对一的内核级线程](https://demoio.cn:90/blog-image/一对一的内核级线程.png)




***内核线程的优点:***
多处理器系统中，内核能够并行执行同一进程内的多个线程
如果进程中的一个线程被阻塞，能够切换同一进程内的其他线程继续执行（用户级线程的一个缺点）

所有能够阻塞线程的调用都以系统调用的形式实现，代价可观
当一个线程阻塞时，内核根据选择可以运行另一个进程的线程，而用户空间实现的线程中，运行时系统始终运行自己进程中的线程
信号是发给进程而不是线程的，当一个信号到达时，应该由哪一个线程处理它？线程可以“注册”它们感兴趣的信号

***内核线程的特点:***

1.当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用。

3.组合方式

在一些系统中，使用组合方式的多线程实现, 线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行. 一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。

下图说明了用户级与内核级的组合实现方式, 在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合

操作系统提供了 LWP 作为用户线程和内核线程之间的桥梁。 LWP 还是和前面提到的一样，具有内核线程支持，是内核的调度单元，并且用户线程的系统调用要通过 LWP ，因此进程中某个用户线程的阻塞不会影响整个进程的执行。



![轻量级线程的组合方式](https://demoio.cn:90/blog-image/轻量级线程的组合方式.png)
